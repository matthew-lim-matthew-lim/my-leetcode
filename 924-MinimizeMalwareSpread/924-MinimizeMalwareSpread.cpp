class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // Return the node that can be removed from initial to minimise the network spread. 

        // Basically, the graph will be disjoint. 
        // Remove the `initial` node that is connected to the subgraph with the mode nodes, and is the lowest 
        // out of the other `initial` values. 

        // Vector with subgraph number.
        // Start BFS from an unexplored node. Put all the nodes from the BFS into a visited set. 
        // At the end of the BFS, write the size of the set into an array with all the node ids. 
        int n = graph.size();
        unordered_map<int, vector<int>> adjList;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j]) {
                    adjList[i].push_back(j);
                }
            }
        }

        unordered_set<int> initialSet(initial.begin(), initial.end());

        vector<int> subgraphSizes(n, 0);

        unordered_set<int> unvisited;
        for (int i = 0; i < n; i++) {
            unvisited.insert(i);
        }

        while (!unvisited.empty()) {
            int initialCount = 0;

            int unvisitedNode = *unvisited.begin();
            unvisited.erase(unvisitedNode);
            // BFS from an unvisited node.
            queue<int> q;
            unordered_set<int> visited;
            q.push(unvisitedNode);
            visited.insert(unvisitedNode);
            while (!q.empty()) {
                int currNode = q.front();
                q.pop();
                if (initialSet.contains(currNode)) {
                    initialCount++;
                }

                for (int neigh : adjList[currNode]) {
                    if (visited.contains(neigh)) {
                        continue;
                    }
                    visited.insert(neigh);
                    unvisited.erase(neigh);

                    q.push(neigh);
                }
            }

            // Now, record the size of this subgraph for all nodes in this subgraph. 
            // But ONLY PUT IT IN SUBGRAPH SIZES IF ONLY 1 INITIAL NODE IS USED!
            // Otherwise, removing it will not affect the malware spread. 
            if (initialCount == 1) {
                int subgraphSize = visited.size();
                for (int node : visited) {
                    subgraphSizes[node] = subgraphSize;
                }
            }
        }

        // Now, get the index with the biggest subgraphSize.
        int biggestSubgraph = INT_MIN;
        int res = n - 1;
        for (int i : initial) {
            if (subgraphSizes[i] > biggestSubgraph || (subgraphSizes[i] == biggestSubgraph && i < res)) {
                biggestSubgraph = subgraphSizes[i];
                res = i;
            }
        }

        return res;
    }
};